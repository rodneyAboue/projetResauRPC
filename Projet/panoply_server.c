/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <time.h>
#include "panoply.h"

boolean *creercompte_1_svc(compte *argp, struct svc_req *rqstp)
{
	static boolean  result;

	if (globaleCompte==(MONMAX-1))
	{
		result=false;
	}
	else
	{
		strcpy(tableauCompte[globaleCompte].nom, argp->nom);
		strcpy(tableauCompte[globaleCompte].prenom, argp->prenom);
		tableauCompte[globaleCompte].identifiant=globaleCompte;
		strcpy(tableauCompte[globaleCompte].mdp, argp->mdp);
		strcpy(tableauCompte[globaleCompte].adresse, argp->adresse);
		tableauCompte[globaleCompte].monType=argp->monType;
		globaleCompte++;
		result=true;
	}

	return &result;
}


boolean *seconnecter_1_svc(compte *argp, struct svc_req *rqstp)
{
	static boolean  result;

	result =0;

	for (int i = 0; i < globaleCompte; i++)
	{
		if (

			((
				(strcmp(tableauCompte[i].nom,argp->nom)==0)
				&&
				(strcmp(tableauCompte[i].prenom,argp->prenom)==0)
			 ) 
			||(tableauCompte[i].identifiant==argp->identifiant) 
			)
 			&& 
			(strcmp(tableauCompte[i].mdp,argp->mdp)==0)
			)
		{
			result=1;
			return &result;
		}
		
	}
	
	return &result;
}

compte *
affichercompte_1_svc(int *argp, struct svc_req *rqstp)
{
	static compte  result;

	strcpy(result.nom ,tableauCompte[*argp].nom);
	strcpy(result.prenom, tableauCompte[*argp].prenom);
	result.identifiant=tableauCompte[*argp].identifiant;
	strcpy(result.mdp, tableauCompte[*argp].mdp);
	strcpy(result.adresse, tableauCompte[*argp].adresse);
	result.monType=tableauCompte[*argp].monType;
	result.monEngagement.etat=tableauCompte[*argp].monEngagement.etat;
	strcpy(result.monEngagement.abn.nomabn,tableauCompte[*argp].monEngagement.abn.nomabn);

	return &result;
}

int *nombrecompte_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	result=globaleCompte;
	return &result;
}

boolean *creerabonnement_1_svc(abonnement *argp, struct svc_req *rqstp)
{
	static boolean  result;

	if (globaleAbonnement==MONMAX-1)
	{
		result=false;
	}
	else
	{
		
		strcpy(tableauAbonnement[globaleAbonnement].nomabn,argp->nomabn);
		tableauAbonnement[globaleAbonnement].prix=argp->prix;
		tableauAbonnement[globaleAbonnement].nombreCredit=argp->nombreCredit;
		tableauAbonnement[globaleAbonnement].globaleAbonnement=globaleAbonnement;
		globaleAbonnement++;
		result=true;
	}

	return &result;
}

int *nombreabonnement_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	result=globaleAbonnement;
	return &result;
}

abonnement *afficherabonnement_1_svc(int *argp, struct svc_req *rqstp)
{
	static abonnement  result;
	strcpy(result.nomabn,tableauAbonnement[*argp].nomabn);
	result.prix=tableauAbonnement[*argp].prix;
	result.identifiant=tableauAbonnement[*argp].identifiant;
	result.nombreCredit=tableauAbonnement[*argp].nombreCredit;
	return &result;
}

boolean *majunabonnement_1_svc(abonnement *argp, struct svc_req *rqstp)
{
	static boolean  result;
	/*parcours permettant de verifier si l'abonnement existe*/
		result=false;
		if (argp->identifiant>=globaleAbonnement)
		{

		}
		else
		{
			int c=argp->identifiant;
			tableauAbonnement[c].identifiant=c;
			strcpy(tableauAbonnement[c].nomabn,argp->nomabn);
			tableauAbonnement[c].prix=argp->prix;
			tableauAbonnement[c].nombreCredit=argp->nombreCredit;
			result=true;
		}
		
	return &result;
}
boolean *affectationabonnement_1_svc(compte *argp, struct svc_req *rqstp)
{
	static boolean  result;
	result=false;
	if (argp->identifiant>= globaleCompte || argp->monEngagement.abn.identifiant>=globaleAbonnement)
	{
		/* code */
	}
	else
	{
		result=true;
		int day, mois, an;
	  	time_t now;
    
	  	// Renvoie l'heure actuelle
	  	time(&now);
	
		struct tm *local = localtime(&now);
	  	day = local->tm_mday;          
	  	mois = local->tm_mon + 1;     
	 	an = local->tm_year + 1900; 

 		int c=argp->identifiant;
 		tableauCompte[c].monEngagement.debut.jour=day;
 		tableauCompte[c].monEngagement.debut.mois=mois;
 		tableauCompte[c].monEngagement.debut.annee=an;

	 	tableauCompte[c].monEngagement.fin.jour=day;
	 	if (mois==12)
	 	{
	 		tableauCompte[c].monEngagement.fin.mois=1;
	 		tableauCompte[c].monEngagement.fin.annee=an+1;
	 	}
	 	else
	 	{
			tableauCompte[c].monEngagement.fin.mois=mois;
		 	tableauCompte[c].monEngagement.fin.annee=an; 		
	 	}
	 	tableauCompte[c].monEngagement.etat=abonne;
	 	tableauCompte[c].monEngagement.abn.identifiant=argp->monEngagement.abn.identifiant;
	 	strcpy(tableauCompte[c].monEngagement.abn.nomabn,tableauAbonnement[argp->monEngagement.abn.identifiant].nomabn);
	 	tableauCompte[c].monEngagement.abn.prix=tableauAbonnement[argp->monEngagement.abn.identifiant].prix;
		tableauCompte[c].monEngagement.abn.nombreCredit=tableauAbonnement[argp->monEngagement.abn.identifiant].nombreCredit;	
	}
	

	return &result;
}

boolean *creercollection_1_svc(collection *argp, struct svc_req *rqstp)
{
	static boolean  result;

	if (globaleCollection==MONMAX-1)
	{
		result=false;
	}
	else
	{
		
		strcpy(tableauCollection[globaleCollection].nomCollection,argp->nomCollection);
		tableauCollection[globaleCollection].idCollection=globaleCollection;
		globaleCollection++;
		result=true;
	}

	return &result;
}

int *nombrecollection_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	result=globaleCollection;
	return &result;
}

collection *affichercollection_1_svc(int *argp, struct svc_req *rqstp)
{
	static collection  result;
	strcpy(result.nomCollection,tableauCollection[*argp].nomCollection);
	result.idCollection=tableauCollection[*argp].idCollection;
	return &result;
}

boolean *associervetementcollection_1_svc(vetement *argp, struct svc_req *rqstp)
{
	static boolean  result;
	result=false;
	if (argp->idVetement>=globaleVetement || argp->maCollection.idCollection>=globaleCollection)
	{
		/* code */
	}
	else
	{
		strcpy(tableauVetement[argp->idVetement].maCollection.nomCollection,argp->maCollection.nomCollection);
		tableauVetement[argp->idVetement].idCollection=argp->maCollection.idCollection;
		result=true;
	}

	return &result;
}

boolean *creervetement_1_svc(vetement *argp, struct svc_req *rqstp)
{
	static boolean  result;
	result=false;
	if (globaleVetement==MONMAX-1)
	{
		
	}
	else
	{
		result=true;
		strcpy(tableauVetement[globaleVetement].nomVetement,argp->nomVetement);
		tableauVetement[globaleVetement].prixVetement=argp->prixVetement;
		tableauVetement[globaleVetement].idVetement=globaleVetement;
		tableauVetement[globaleVetement].nbCredit=argp->nbCredit;
		tableauVetement[globaleVetement].nbExemplaire=argp->nbExemplaire;
		globaleVetement++;
	}

	return &result;
}

vetement *affichervetement_1_svc(int *argp, struct svc_req *rqstp)
{
	static vetement  result;
	strcpy(result.nomVetement,tableauVetement[*argp].nomVetement);
	result.prixVetement=tableauVetement[*argp].prixVetement;
	result.nbCredit=tableauVetement[*argp].nbCredit;
	result.nbExemplaire=tableauVetement[*argp].nbExemplaire;

	return &result;
}

int *nombrevetement_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	result=globaleVetement;
	return &result;
}

boolean *louervetement_1_svc(location *argp, struct svc_req *rqstp)
{
	static boolean  result;
	result=false;
	if (globaleLocation==MONMAX-1)
	{
		/* code */
	}
	else
	{
		
	}

	return &result;
}

int *
nombrelocation_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	result=globaleLocation;
	return &result;
}

location *
afficherlocation_1_svc(int *argp, struct svc_req *rqstp)
{
	static location  result;

	/*
	 * insert server code here
	 */

	return &result;
}
