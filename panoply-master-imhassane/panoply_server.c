/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <string.h>
#include <time.h>
#include "panoply.h"

// Initialisation des tables.
static collections_list_t collections_list;

static occasions_list_t occasions_list;

static brands_list_t brands_list;

static clothes_list_t clothes_list;

static rentals_list_t rentals_list;

static members_list_t members_list;

static subscriptions_list_t subscriptions_list;

int *
register_1_svc(new_member_params *argp, struct svc_req *rqstp)
{
	static int  result;

	static member_t member;

	strcpy(member.first_name, argp->first_name);
	strcpy(member.last_name, argp->last_name);
	strcpy(member.password, argp->password);
	strcpy(member.address, argp->address);

	member.type = 1;
	if(members_list.last_inserted == 0)
		member.type = 0;

	member.id = members_list.last_inserted;

	members_list.data[members_list.last_inserted] = member;
	members_list.last_inserted++;

	return &result;
}

int *
login_1_svc(login_member_params *argp, struct svc_req *rqstp)
{
	static int  result;

	int found = 0, index = 0, valid_username = -1, valid_password = -1;
	while(found == 0 && index < members_list.last_inserted) {
	   valid_username = strcmp(members_list.data[index].user_name, argp->user_name);
	   valid_password = strcmp(members_list.data[index].password, argp->password);

	   if(valid_username == 0 && valid_password == 0)
	     found = 1;
	   else
	     index++;
	}

	// Si l'utilisateur est trouvé, on retourne son identifiant.
	if(found == 1) result = members_list.data[index].id;

	return &result;
}

int *
total_members_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	result = members_list.last_inserted;

	return &result;
}

member_t *
show_member_1_svc(int *argp, struct svc_req *rqstp)
{
	static member_t  result;

	int found = 0, index = 0;
	while(found == 0 && index < members_list.last_inserted) {
	  if(members_list.data[index].id == *argp)
	    found = 1;
	  else
	    index++;
	}

	if(found == 1) result = members_list.data[index];

	return &result;
}

int *
new_subscription_1_svc(subscription_t *argp, struct svc_req *rqstp)
{
	static int  result;

	subscriptions_list.data[subscriptions_list.last_inserted] = *argp;
	subscriptions_list.last_inserted++;

	return &result;
}

int *
total_subscriptions_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	result = subscriptions_list.last_inserted;

	return &result;
}

subscription_t *
show_subscription_1_svc(int *argp, struct svc_req *rqstp)
{
	static subscription_t  result;

	int found = 0, index = 0;
	while(found == 0 && index < subscriptions_list.last_inserted) {
	  if((subscriptions_list.data[index]).type == *argp)
	    found = 1;
	  else
	    index++;
	}

	if(found == 1) result = (subscriptions_list.data[index]);

	return &result;
}

int *
update_subscription_1_svc(subscription_t *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */

	return &result;
}

int *
set_member_subscription_1_svc(set_member_subscription_params *argp, struct svc_req *rqstp)
{
	static int  result;

	static member_t member;
	subscription_t * subscription = NULL;

	int user_found = 0, index = 0;
	while(user_found == 0 && index < members_list.last_inserted) {
		if(members_list.data[index].id == argp->member_id) {
			user_found = 1;
		}

		if(user_found == 1)
			member = members_list.data[index];
		else
			index++;
	}

	subscription = &subscriptions_list.data[argp->subscription_id];
	if(subscription != NULL) {
		member.subscription.is_valid = 1;
		member.subscription.subscription = subscription;

		time_t _time = time(NULL);
		struct tm * infos = localtime(&_time);

		date_t start_date;
		date_t end_date;

		start_date.day = infos->tm_mday;
		start_date.month = infos->tm_mon;
		start_date.year = infos->tm_year;

	 	end_date.day = infos->tm_mday;
		end_date.month = (1 + infos->tm_mon) % 12;
		end_date.year = infos->tm_year;

		member.subscription.first_month.total_credits = subscription->credits;
		member.subscription.first_month.current_usage = 0;
		member.subscription.first_month.start_date = start_date;
		member.subscription.first_month.end_date = end_date;

		start_date.day = infos->tm_mday;
		start_date.month = end_date.month;
		start_date.year = infos->tm_year;

	 	end_date.day = infos->tm_mday;
		end_date.month = (2 + infos->tm_mon) % 12;
		end_date.year = infos->tm_year;

		member.subscription.second_month.total_credits = subscription->credits;
		member.subscription.second_month.current_usage = 0;
		member.subscription.second_month.start_date = start_date;
		member.subscription.second_month.end_date = end_date;

		start_date.day = infos->tm_mday;
		start_date.month = end_date.month;
		start_date.year = infos->tm_year;

	 	end_date.day = infos->tm_mday;
		end_date.month = (3 + infos->tm_mon) % 12;
		end_date.year = infos->tm_year;

		member.subscription.third_month.total_credits = subscription->credits;
		member.subscription.third_month.current_usage = 0;
		member.subscription.third_month.start_date = start_date;
		member.subscription.third_month.end_date = end_date;
	}
	return &result;
}

int *
new_collection_1_svc(new_collection_params *argp, struct svc_req *rqstp)
{
	static int  result;

	static collection_t collection;

	collection.id = collections_list.last_inserted;
	strcpy(collection.name, argp->name);

	collections_list.data[collections_list.last_inserted] = collection;

	return &result;
}

int *
total_collections_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	result = collections_list.last_inserted;

	return &result;
}

collection_t *
show_collection_1_svc(int *argp, struct svc_req *rqstp)
{
	static collection_t  result;

	int index = 0, found = 0;
	while(found == 0 && index < collections_list.last_inserted) {
		if(*argp == collections_list.data[index].id)
			found = 1;
		else
			index++;
	}

	if(found == 1) result = collections_list.data[index];

	return &result;
}

int *
set_clothing_collecton_1_svc(set_clothing_collection_params *argp, struct svc_req *rqstp)
{
	static int  result;

	static cloth_t * my_cloth;
	static collection_t * collection;

	my_cloth = &(clothes_list.data[argp->clothing_id]);
	collection = &collections_list.data[argp->collection_id];

	my_cloth->collection = collection;
	result = 0;
	return &result;
}

int *
new_clothing_1_svc(new_clothing_params *argp, struct svc_req *rqstp)
{
	static int  result;

	static cloth_t cloth;

	strcpy(cloth.name, argp->name);
	cloth.price = argp->price;
	cloth.credits = argp->credits;
	cloth.stock = argp->stock;
	cloth.id = clothes_list.last_inserted;

	clothes_list.data[clothes_list.last_inserted] = cloth;
	clothes_list.last_inserted++;

	result = 0;
	return &result;
}

int *
total_clothings_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	result = clothes_list.last_inserted;

	return &result;
}

cloth_t *
show_clothing_1_svc(int *argp, struct svc_req *rqstp)
{
	static cloth_t  result;

	int found = 0, index = 0;
	while(found == 0 && index < clothes_list.last_inserted) {
		if(clothes_list.data[index].id == *argp)
			found = 1;
		else
			index++;
	}
	if(found == 1) result = clothes_list.data[index];

	return &result;
}

int *
rent_clothing_1_svc(int *argp, struct svc_req *rqstp)
{
	static int  result;
	struct rental_t rental;
	static cloth_t * cloth;

	result = -1;

	// On récupère le vêtement à louer.
	int found = 0, index = 0;
	while(found == 0 && index < clothes_list.last_inserted) {
		if(clothes_list.data[index].id == *argp)
			found = 1;
		else
			index++;
	}

	if(found == 1) {
		cloth = &clothes_list.data[index];
		if(cloth != NULL) {
				rental.cloth = cloth;
				rental.rental_state = 0;
				rentals_list.data[rentals_list.last_inserted] = rental;
				rentals_list.last_inserted++;

				result = 0;
		} else {
			result = -1;
		}
	}

	return &result;
}

int *
total_rents_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	result = rentals_list.last_inserted;

	return &result;
}

rental_t *
show_rental_1_svc(int *argp, struct svc_req *rqstp)
{
	static rental_t  result;

	int found = 0, index = 0;
	while(found == 0 && index < rentals_list.last_inserted) {
		if((rentals_list.data[index]).id == *argp)
			found = 1;
		else
			index++;
	}

	if(found == 1) result = rentals_list.data[index];

	return &result;
}

clothes_list_t *
list_clothes_1_svc(void *argp, struct svc_req *rqstp)
{
	static clothes_list_t  result;

	result = clothes_list;

	return &result;
}
